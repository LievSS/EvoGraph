import random
import math
from config import config
from datalogger import DataLogger


# Base class for nodes
class Node:
    def __init__(self, id, dna):
        self.id = id
        self.dna = dna  # Node's DNA, either SpeciesA or SpeciesB
        self.activation_level = 0  # Neural-inspired activation level
        self.fitness = 1  # Fitness score
        self.energy = self.dna.energy  # Start with the DNA's energy level
        self.energy_sources = []  # List to track energy sources

    def add_energy_source(self, source):
        # Add an energy source for the node to interact with.
        self.energy_sources.append(source)

    def interact_with_energy_sources(self):
        # Interact with energy sources to replenish energy.
        for source in self.energy_sources:
            if source.energy > 0:
                self.energy += source.energy_replenishment
                source.energy -= source.energy_replenishment  # Decrease source energy
                print(f"Node {self.id} interacted with {source.id} and gained energy.")

    def interact(self, neighbors, weights):
        # Interact with neighboring nodes based on weighted connections, energy cost.
        if self.energy > config["energy_threshold"]:  # Interaction requires energy
            avg_neighbor_strength = sum(neighbor.dna.interaction_strength for neighbor in neighbors) / len(neighbors)
            self.dna.interaction_strength = (self.dna.interaction_strength + avg_neighbor_strength) / 2

            weighted_sum = sum(neighbor.dna.interaction_strength * weights.get(neighbor.id, 1) for neighbor in neighbors)
            self.activation_level = self.activation_function(weighted_sum)
            self.energy -= config["energy_threshold"]  # Energy cost for interacting
        print(f"Node {self.id} Interaction: Activation Level={self.activation_level}, Energy={self.energy}")

    def activation_function(self, input_sum):
        # Sigmoid activation function, common in neural networks.
        return 1 / (1 + math.exp(-input_sum + self.dna.activation_threshold))

    def receive_feedback(self, success):
        # Adjust node's behavior based on feedback, with energy reward or penalty.
        feedback_factor = 1.1 if success else 0.9
        self.dna.mutation_rate *= feedback_factor
        self.fitness *= feedback_factor
        self.energy += 20 if success else -10  # Gain or lose energy based on feedback
        print(f"Node {self.id} Feedback: Mutation Rate={self.dna.mutation_rate}, Fitness={self.fitness}, Energy={self.energy}")

    def regenerate_energy(self):
        # Energy replenishment, based on environmental factors.
        self.energy = min(self.energy + config["environment_energy"], 100)  # Regenerate a small amount of energy each cycle, capped at 100

# Hypergraph class
class Hypergraph:
    def __init__(self):
        self.nodes = []
        self.hyperedges = {
            "cooperative": [],
            "competitive": []
        }
        self.hyperedge_weights = {}
        self.global_mutation_rate = config["global_mutation_rate"]
        self.logger = DataLogger(config["log_file"])

    def add_node(self, node):
        # Add a node to the hypergraph.
        self.nodes.append(node)

    def form_new_hyperedge(self, nodes, interaction_type):
        # Create a new hyperedge with weighted connections between nodes.
        self.hyperedges[interaction_type].append(nodes)
        self.hyperedge_weights[tuple(node.id for node in nodes)] = {
            node.id: random.uniform(config["interaction_strength_range"][0], config["interaction_strength_range"][1]) for node in nodes
        }

    def evolve_hyperedges(self):
        # Recreate hyperedges if any node's DNA changes significantly.
        for interaction_type, hyperedges in self.hyperedges.items():
            new_hyperedges = []
            for hyperedge in hyperedges:
                if any(node.dna.mutation_rate > 0.5 for node in hyperedge):
                    self.form_new_hyperedge(hyperedge, interaction_type)  # Recreate the hyperedge
                else:
                    new_hyperedges.append(hyperedge)  # Retain unchanged hyperedges
            self.hyperedges[interaction_type] = new_hyperedges  # Update the hyperedges list

    def evolve(self, generations=10):
        # Run the evolutionary process with energy dynamics.
        for gen in range(generations):
            print(f"Generation {gen}")
            selected_nodes = self.nodes[:]

            # Log initial state of nodes
            for node in selected_nodes:
                self.logger.log(gen, node)

            for node in selected_nodes:
                node.dna.mutate()
                node.regenerate_energy()  # Regenerate energy at the start of each generation
                node.interact(selected_nodes, self.hyperedge_weights)

            # Check for feedback and adjust nodes
            for node in selected_nodes:
                success = random.choice([True, False])  # Simulate feedback for the example
                node.receive_feedback(success)

            # Recreate hyperedges based on mutations
            self.evolve_hyperedges()

            # Print node states for debugging
            for node in selected_nodes:
                print(f"Node {node.id}: Energy={node.energy}, Activation Level={node.activation_level}")


